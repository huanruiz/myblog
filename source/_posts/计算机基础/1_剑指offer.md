---
title: 剑指offer题目总结
date: 2020/7/17
categories: 
- 计算机基础
tags: [数据结构与算法]
---

这是我的剑指offer题目小总结, 我打算用分类的方法来复习数据结构与算法来提高效率. 这篇文章主要包含的是剑指offer第二版的题目(lc上面的). 题目包含在剑指上面的编号和括号中对应的在leetcode主题目的编号.
<!-- more -->

## 链表
### 06.从尾到头打印链表
1.栈辅助, 但是动态增加长度可能会消耗多余空间, 直接遍历得到长度并用固定长度数组也不失为一种好办法; 2.官方讲了递归的方法, 本质也是遍历.

> 不要再循环中用用stack.size(); 输出的是int[];

### 18.删除链表的节点
注意删除头指针的情况.

### 22.链表中倒数第k个节点
比较自然想到双指针, end先走k步, front和end在一起走, front和end距离保持为k.

### 24.反转链表
1.双指针, 用两个相邻指针遍历数组. 2.递归, 天然的用上一层来记录各个节点位置

```
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode node = reverseList(head.next);
    head.next.next = head; // 翻转两个node
    head.next = null; // 去除正向的指针
    return node;
}
```

> 输入为空, 输入只有head的情况要区分.

### 35.复杂链表的复制. 
做容易想到的就是用HashMap来存<原链表, 新链表>键值对再一一链接. 遍历时可以当做遍历一个图, 用dfs, bfs即可. 否则需要顺序遍历两次.
```
class Solution {

    HashMap<Node, Node> map = new HashMap<>();

    public Node copyRandomList(Node head) {
        return dfs(head);
    }

    private Node dfs(Node head) {
        if (head == null) {
            return head;
        }
        if (map.containsKey(head)) {
            return map.get(head);
        }

        Node node = new Node(head.val);
        map.put(head, node);
        node.next = dfs(head.next);
        node.random = dfs(head.random);
        return node;
    }
}
```

### 52.两个链表的第一个公共节点
1.我首先想到的就是遍历链表A再把node存起来, 再遍历链表B比较; 2.浪漫的做法是双指针, 遍历A+B两个链表的总步数一样, 如果有相同的小尾巴, 那么双指正一定会相遇, 主要节省了空间复杂度O(1).

## 树
### 07.重建二叉树(105)
pre确定根, in确定左, 联合确定右. 用递归生成root已经左右子树. 无重复值这个条件其实就是一个提醒. 

### 26.树的子结构
主递归搜索所有的A子树, 用子递归遍历所有node.

### 27.二叉树的镜像(226)
递归让左边等于右边的翻转, 右边等于左边的翻转, 直到该node为null.

### 28.对称的二叉树(101)
1.递归比较子树是否完全对称, ll==rr, lr==rl, 本质上等价于写了非常多的比较; 2.同queue模仿递归比较, 出队一个node, 入队子node并比较. 

### 32-I.从上到下打印二叉树
分层打印, 自然就是用queue来实现BFS搜索了. 

> 注意 Queue queue = new LinkedList(); 不要写错了.

### 32-II.从上到下打印二叉树(102)
1.BFS一层层遍历; 2.DFS并记录层数, res.get(level).add(node.val);给不同层的List添加val.

### 32-III.从上到下打印二叉树
同上做法, 子不过要记录层级, trick是用BFS可以用res长度来得到层级, 也可以直接把左右添加元素的动作写到一起, 就无需判断.

### 34.二叉树中和为某一值的路径(113)
注意路径是从根到叶子, 思想就是DFS加回溯, 删掉加入的node.

### 37.序列化二叉树(297)
序列化逻辑没有限制, 那么bfs, dfs都可以.

> parseInt的使用, equals的使用, index每次累加都要检查是否出界.

### 54.二叉搜索树的第k大节点
可以用字段来减少运行时间, dfs.

### 55-I.二叉树的深度(104)
dfs.

### 55-II.平衡二叉树(110)
1.目的就是使每个root的左右节点深度小于2, 那么先递归求深度就可以直接判断了, 时间O(n^2); 2.自底向上, 避免重复计算depth, 优化时间空间到O(n).
```
class Solution {
    public boolean isBalanced(TreeNode root) {
        return depth(root) != -1;
    }
​
    private int depth(TreeNode root) {
        if (root == null) return 0;
        int left = depth(root.left);
        if(left == -1) return -1;
        int right = depth(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    }
}
```

### 68-I.二叉搜索树的最近公共祖先(235)
1.首先要注意二叉搜索树有左小于右的特点. 那么简单的比较大小就好了. 2.用迭代代替递归可以节省空间, 时间O(n),空间O(1).

### 68-II.二叉树的最近公共祖先(236)
后续搜索, 节点存在则返回, 否则返回null 就可以知道要求的节点在左还是右.

## 栈, 队列与堆
### 09.用两个栈实现队列
一个栈用来入, 一个栈用来出.

### 30.包含min函数的栈(155)
为了时间复杂度, 必须要用辅助栈来记录最小值, 一个数如果最小那么直到它出栈, 一直都是最小的, 所以可以用辅助栈记住这个最小值.

### 59-II.队列的最大值
1.方法同上. 同样要用队列来记录最大值, 每个值只会对前面的只有影响; 2.动态规划

### 40.最小的k个数
1.排序O(nlogn); 2.Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1) O(nlogk). 新进来的元素小, 就要把大的先poll掉, 再offer;

### 41.数据流中的中位数(295)
思想延续了栈和队列, 这里考虑用两个堆.

## 哈希表
### 03.数组中重复的数字
1.直接用HashMap或者HashSet的性质来判断; 2.看题目, 数组内元素大小都小于数组长度, 就可以用置换的办法, 把元素移动到其值对应的索引位置, 如果发现重复了, 就得到结果.

### 48.最长不含重复字符的子字符串(3)
滑动窗口

### 50.第一个只出现一次的字符
哈希表看是否出现, trick一点可以用数组以字符的unicode作为下标.

## 数组
### 04.二维数组中的查找(240)
从左下或者右上开始搜索. 从坐下开始, 向右就是增加, 向上就是减小.

### 29.顺时针打印矩阵(54)
把上下左右边界标出来, 用++x和x++语法减少代码量.

### 53-I.在排序数组中查找数字(34)
二分法找.

### 53-II.0到n-1中缺失的数字
二分法, 比较中值的点和对应的索引大小就可以知道, 缺失的值在左边还是右边.

## 递归&动态规划
### 10-I.斐波那契数列(509)
1.直接递归会超时, 时间$O(2^{n})$,空间$O(n)$, 当然对这个方法可以把计算过的结果保存下来, 时间复杂度就降为O(n), 这是自顶向下; 2.用数组来存储每一个值, 时间$O(n)$,空间$O(n)$, 也可以优化成只记录前两个值, 那么空间会下降到O(1), 这是**动态规划**的思想, 也是自底向上.

### 10-II.青蛙跳台阶问题(70)
这到题就是包装起来的斐波那契数列. 方法同上. 

### 16.数值的整数次方(50)
1.自顶向下递归, 也就是分治为奇偶. 注意这里在判断幂的奇偶之前, 可以先把子递归的值记录下来, 不要直接return子递归的积, 否则会超时. 这里的时间复杂度是$O(logn)$, 空间复杂度也是$O(logn)$, 空间复杂度是因为用了栈空间; 2.自底向上比较trick, 想象这是一个二进制数, 从左到右为1的每一位会多贡献一次幂, 剩下的就是自己和自己相乘, 空间复杂度就会降为O(1).

> 注意n的范围是$[−2^{31}, 2^{31}−1]$, 也就是说int n的情况下当n为$−2^{31}$是不能取负, 那么就需要用long N = n来把这个n的值记录下来.

## 位运算