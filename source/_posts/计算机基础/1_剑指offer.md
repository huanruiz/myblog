---
title: 剑指offer题目总结
date: 2020/7/17
categories: 
- 计算机基础
tags: [数据结构与算法]
---

这是我的剑指offer题目小总结, 我打算用分类的方法来复习数据结构与算法来提高效率. 这篇文章主要包含的是剑指offer第二版的题目(lc上面的). 题目包含在剑指上面的编号和括号中对应的在leetcode主题目的编号.
<!-- more -->

## 数组
### 04.二维数组中的查找(240)
从左下或者右上开始搜索. 从坐下开始, 向右就是增加, 向上就是减小.

### 21.调整数组顺序使奇数位于偶数前面
1.用新的数组来存, 前后指针指向插入位置; 2.快慢指针, 慢指针找偶数, 快指针找奇数; 3.更易于理解的前后指针, 前指针找偶, 后指针找奇数, 前偶后奇则交换.

## 字符串
### 17.打印从1到最大的n位数
1.这道题返回的是int, 其实可以直接打印不怕越界. 2.加大难度, 如果有大数情况, 用字符串表示.**todo**.

### 45.把数组排成最小的数

## 链表
### 06.从尾到头打印链表
1.栈辅助, 但是动态增加长度可能会消耗多余空间, 直接遍历得到长度并用固定长度数组也不失为一种好办法; 2.官方讲了递归的方法, 本质也是遍历.

> 不要再循环中用用stack.size(); 输出的是int[];

### 18.删除链表的节点
注意删除头指针的情况.

### 22.链表中倒数第k个节点
比较自然想到双指针, end先走k步, front和end在一起走, front和end距离保持为k.

### 24.反转链表
1.双指针, 用两个相邻指针遍历数组. 2.递归, 天然的用上一层来记录各个节点位置

```
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode node = reverseList(head.next);
    head.next.next = head; // 翻转两个node
    head.next = null; // 去除正向的指针
    return node;
}
```

> 输入为空, 输入只有head的情况要区分.

### 35.复杂链表的复制. 
做容易想到的就是用HashMap来存<原链表, 新链表>键值对再一一链接. 遍历时可以当做遍历一个图, 用dfs, bfs即可. 否则需要顺序遍历两次.
```
class Solution {

    HashMap<Node, Node> map = new HashMap<>();

    public Node copyRandomList(Node head) {
        return dfs(head);
    }

    private Node dfs(Node head) {
        if (head == null) {
            return head;
        }
        if (map.containsKey(head)) {
            return map.get(head);
        }

        Node node = new Node(head.val);
        map.put(head, node);
        node.next = dfs(head.next);
        node.random = dfs(head.random);
        return node;
    }
}
```

### 52.两个链表的第一个公共节点
1.我首先想到的就是遍历链表A再把node存起来, 再遍历链表B比较; 2.浪漫的做法是双指针, 遍历A+B两个链表的总步数一样, 如果有相同的小尾巴, 那么双指正一定会相遇, 主要节省了空间复杂度O(1).

## 树
树的题基本都会用到递归, 不是递归就是BFS(queue)或者DFS(stack). 当然如同前中后序遍历的递归也可以看作dfs.

### 07.重建二叉树(105)
pre确定根, in确定左, 联合确定右. 用递归生成root已经左右子树. 无重复值这个条件其实就是一个提醒. 

### 26.树的子结构
主递归搜索所有的A子树, 用子递归遍历所有node.

### 27.二叉树的镜像(226)
递归让左边等于右边的翻转, 右边等于左边的翻转, 直到该node为null.

### 28.对称的二叉树(101)
1.递归比较子树是否完全对称, ll==rr, lr==rl, 本质上等价于写了非常多的比较; 2.同queue模仿递归比较, 出队一个node, 入队子node并比较. 

### 32-I.从上到下打印二叉树
分层打印, 自然就是用queue来实现BFS搜索了. 

> 注意 Queue queue = new LinkedList(); 不要写错了.

### 32-II.从上到下打印二叉树(102)
1.BFS一层层遍历; 2.DFS并记录层数, res.get(level).add(node.val);给不同层的List添加val.

### 32-III.从上到下打印二叉树
同上做法, 子不过要记录层级, trick是用BFS可以用res长度来得到层级, 也可以直接把左右添加元素的动作写到一起, 就无需判断.

### 34.二叉树中和为某一值的路径(113)
注意路径是从根到叶子, 思想就是DFS加回溯, 删掉加入的node.

### 37.序列化二叉树(297)
序列化逻辑没有限制, 那么bfs, dfs都可以.

> parseInt的使用, equals的使用, index每次累加都要检查是否出界.

### 54.二叉搜索树的第k大节点
可以用字段来减少运行时间, dfs.

### 55-I.二叉树的深度(104)
dfs.

### 55-II.平衡二叉树(110)
1.目的就是使每个root的左右节点深度小于2, 那么先递归求深度就可以直接判断了, 时间O(n^2); 2.自底向上, 避免重复计算depth, 优化时间空间到O(n).
```
class Solution {
    public boolean isBalanced(TreeNode root) {
        return depth(root) != -1;
    }
​
    private int depth(TreeNode root) {
        if (root == null) return 0;
        int left = depth(root.left);
        if(left == -1) return -1;
        int right = depth(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    }
}
```

### 68-I.二叉搜索树的最近公共祖先(235)
1.首先要注意二叉搜索树有左小于右的特点. 那么简单的比较大小就好了. 2.用迭代代替递归可以节省空间, 时间O(n),空间O(1).

### 68-II.二叉树的最近公共祖先(236)
后续搜索, 节点存在则返回, 否则返回null 就可以知道要求的节点在左还是右.

## 栈, 队列与堆
### 09.用两个栈实现队列
一个栈用来入, 一个栈用来出.

### 30.包含min函数的栈(155)
为了时间复杂度, 必须要用辅助栈来记录最小值, 一个数如果最小那么直到它出栈, 一直都是最小的, 所以可以用辅助栈记住这个最小值.

### 59-II.队列的最大值
1.方法同上. 同样要用队列来记录最大值, 每个值只会对前面的只有影响; 2.动态规划

### 40.最小的k个数
1.排序O(nlogn); 2.Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1) O(nlogk). 新进来的元素小, 就要把大的先poll掉, 再offer;

### 41.数据流中的中位数(295)
思想延续了栈和队列, 这里考虑用两个堆.

## 哈希表
### 03.数组中重复的数字
1.直接用HashMap或者HashSet的性质来判断; 2.看题目, 数组内元素大小都小于数组长度, 就可以用置换的办法, 把元素移动到其值对应的索引位置, 如果发现重复了, 就得到结果.

### 48.最长不含重复字符的子字符串(3)
滑动窗口

### 50.第一个只出现一次的字符
哈希表看是否出现, trick一点可以用数组以字符的unicode作为下标.

### 29.顺时针打印矩阵(54)
把上下左右边界标出来, 用++x和x++语法减少代码量.

### 53-I.在排序数组中查找数字(34)
二分法找.

### 53-II.0到n-1中缺失的数字
二分法, 比较中值的点和对应的索引大小就可以知道, 缺失的值在左边还是右边.

## 递归&动态规划
大多数其实都是动态规划的题. dp主要是自底向上解决问题, 而递归是暴力的自顶向下, 一般会超时. 所以如果用递归的话需要记忆化来存储已经计算的值. 动态规划也可以优化, 大多是优化空间, 用几个值来代替数组, 存储上几个状态的值.

### 10-I.斐波那契数列(509)
1.直接递归会超时, 时间$O(2^{n})$,空间$O(n)$, 当然对这个方法可以把计算过的结果保存下来, 时间复杂度就降为O(n), 这是自顶向下; 2.用数组来存储每一个值, 时间$O(n)$,空间$O(n)$, 也可以优化成只记录前两个值, 那么空间会下降到O(1), 这是**动态规划**的思想, 也是自底向上.

### 10-II.青蛙跳台阶问题(70)
这到题就是包装起来的斐波那契数列. 方法同上. 

### 16.数值的整数次方(50)
1.自顶向下递归, 也就是分治为奇偶. 注意这里在判断幂的奇偶之前, 可以先把子递归的值记录下来, 不要直接return子递归的积, 否则会超时. 这里的时间复杂度是$O(logn)$, 空间复杂度也是$O(logn)$, 空间复杂度是因为用了栈空间; 2.**快速幂, 想象幂这是一个二进制数, 为了达到这个幂的结果, 从左到右为1的每一位会多贡献一次幂, 剩下的就是自己和自己相乘, 迭代和递归本质相同, 快速幂空间复杂度就会降为O(1)**, 这个非常重要, 只要是求幂的地方都会用到.

> 注意n的范围是$[−2^{31}, 2^{31}−1]$, 也就是说int n的情况下当n为$−2^{31}$是不能取负, 那么就需要用long N = n来把这个n的值记录下来.

### 14-I.剪绳子(343)
1.动态规划. 状态转移方程为$f(n) = max(f(n-2)*3 - f(n-3)*3)$. 可以仅用3个值来存储结果, 因为其实结果都是3个为一组的, 想象python中就可以通过声明数组的方式直接共用内存; 2.数学推导的方法比较tricky, 但是能时间空间O(1)解决问题. 3.自顶向下暴力递归, 但是要把值存下来, 否则超时. 4.正常的就是直接动态规划$O(n^{2})时间解决.

### 14-II.剪绳子(343)
在14-I中相乘的数字越多结果越大的结论之下进一步推导. [推导](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/). 所以尽可能要切3, 其次切2. 这道题不能动态规划了, 就只能用此方法. 用Java做的话会面临大数取余的问题, 利用公式$(xy)\ mod\ p=[(x\ mod\ p)(y\ mod\ p)]\ mod\ p$, 知道了$x < p$, 那么就简化为$(x^{a})\ mod\ p=[(x^{a-1}\ mod\ p)x]\ mod\ p$

> $\frac{n_{1}+n_{2}+...+n_{a}}{a} \ge \sqrt[a]{n_{1}\cdot n_{2}\cdot ...\cdot n_{a}}$. 当n都相等时取等号.

### 42.连续子数组的最大和(53)
动态规划, 状态转移方程是$max(f(n)) = max(f(n), f(n-1) + f(n))$, 要么是保留这一项, 要么是继续和之前的连续数组相加.

### 49.丑数(264)
动态规划可以有三个指针p2, p3, p5, 从1开始每个数字都有和这个指针所指向的数字相乘的机会. 那么状态转移方程是$f(n) = min(f(p2)\times2, f(p3)\times3, f(p5)\times5)$.

> 注意不要有重复值, 也就是比较三个值时, 这三个值其中两个可能相等, 指针都要向后移动. 比较大小可以用: "Math.min(Math.min(p2, p3), p5);".

## 位运算
### 15.二进制中1的个数(191)
1. 最简单方法就是遍历这32位, 累加为1的位, 做判断的条件是"xxx != 0", 不能用等于1来判断. 2.进一步省空间直接将n右移, 每次判断第一位, 注意要用n>>>=1, 因为首位是符号位.

### 39.数组中出现次数超过一半的数字(169)
取中位数, 哈希表来存的方法都比较直观. 比较优雅的解法是摩尔投票法.

### 56-I.数组中数字出现的次数
异或. 因为有交换律结合律, 所以最后异或出来的值实际上是两个单独数字的异或. 再根据单独数字的不同位把数字分为两组, 分别异或, 两组的结果就是这两个值.

> 其实可以推广到, 这两个数出现的次数为奇数次, 而其他数出现的次数为偶数次.

### 56-II.数组中数字出现的次数
按位相加, 只要是总数为3的位取余都会为0, 而剩下的为1的位就是结果.

> 可以推广到重复任何次

## 排序
### 51.数组中的逆序对